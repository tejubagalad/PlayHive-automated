name: CI/CD for PlayHive Microservices (Resilient + Auto Heal)

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      # 1Ô∏è‚É£ Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Setup Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3Ô∏è‚É£ Login to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 4Ô∏è‚É£ Build & Push GameHub Image
      - name: Build & Push GameHub Image
        uses: docker/build-push-action@v5
        with:
          context: ./microservice-arch/gamehub-microarch/app
          file: ./microservice-arch/gamehub-microarch/app/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/playhive-auto-app:latest

      # 5Ô∏è‚É£ Build & Push Snake Image
      - name: Build & Push Snake Image
        uses: docker/build-push-action@v5
        with:
          context: ./microservice-arch/gamehub-microarch/SnakeGame
          file: ./microservice-arch/gamehub-microarch/SnakeGame/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/playhive-auto-snake:latest

      # 6Ô∏è‚É£ Build & Push 2048 Image
      - name: Build & Push 2048 Image
        uses: docker/build-push-action@v5
        with:
          context: ./microservice-arch/gamehub-microarch/TwentyFortyEight
          file: ./microservice-arch/gamehub-microarch/TwentyFortyEight/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/playhive-auto-2048:latest

      # 7Ô∏è‚É£ Configure Kubeconfig
      - name: Set up kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config current-context

      # 8Ô∏è‚É£ Wait for AKS API to be reachable (after cluster restart)
      - name: Wait for AKS Cluster API
        run: |
          echo "‚è≥ Waiting for AKS cluster API to become ready..."
          for i in {1..15}; do
            if kubectl cluster-info > /dev/null 2>&1; then
              echo "‚úÖ AKS cluster is reachable!"
              break
            else
              echo "üîÅ Retrying in 20s..."
              sleep 20
            fi
          done

      # 9Ô∏è‚É£ Ensure Ingress Controller is Running
      - name: üß© Ensure Ingress Controller is Running
        run: |
          echo "üîç Checking ingress controller status..."
          if ! kubectl get pods -n ingress-basic 2>/dev/null | grep -q "Running"; then
            echo "‚öôÔ∏è Ingress not running ‚Äî attempting lightweight fix..."

            # Reduce resource usage dynamically to prevent CPU/memory errors
            kubectl patch deployment nginx-ingress-ingress-nginx-controller -n ingress-basic \
              -p '{"spec":{"template":{"spec":{"containers":[{"name":"controller","resources":{"requests":{"cpu":"50m","memory":"64Mi"},"limits":{"cpu":"100m","memory":"128Mi"}}}]}}}}' || true

            # Restart ingress deployment
            kubectl rollout restart deployment nginx-ingress-ingress-nginx-controller -n ingress-basic || true

            # Wait until ingress is available
            kubectl wait --for=condition=available deployment/nginx-ingress-ingress-nginx-controller -n ingress-basic --timeout=180s || true
            echo "‚úÖ Ingress controller is ready now."
          else
            echo "‚úÖ Ingress controller already running."
          fi

      # üîü Install Flux CLI
      - name: Install Flux CLI
        run: |
          curl -sL https://fluxcd.io/install.sh | bash
          export PATH=$PATH:/usr/local/bin
          flux --version

      # 1Ô∏è‚É£1Ô∏è‚É£ Wait for Flux CRDs to Be Ready
      - name: Wait for Flux CRDs to Be Ready
        run: |
          echo "üß† Waiting for Flux components..."
          for i in {1..10}; do
            if kubectl get pods -n flux-system >/dev/null 2>&1; then
              echo "‚úÖ Flux components detected."
              break
            else
              echo "‚è≥ Flux system not yet ready, waiting..."
              sleep 20
            fi
          done

      # 1Ô∏è‚É£2Ô∏è‚É£ Check and Reconcile Flux if Drift Detected
      - name: Check and Reconcile Flux if Drift Detected
        run: |
          echo "üîÅ Checking Flux sync state..."
          if ! flux get kustomizations | grep -q "Ready"; then
            echo "‚ö†Ô∏è Drift detected ‚Äî reconciling..."
            flux reconcile source git flux-system
            flux reconcile kustomization flux-system --with-source
          else
            echo "‚úÖ Flux is already in sync."
          fi

      # 1Ô∏è‚É£3Ô∏è‚É£ Smart Restart (Only If Image Changed)
      - name: Smart Restart (Only if Image Updated)
        run: |
          for dep in gamehub snake game2048; do
            echo "üîç Checking image for $dep..."
            CURRENT_IMAGE=$(kubectl get deployment $dep -o jsonpath='{.spec.template.spec.containers[0].image}' || true)
            if [[ "$CURRENT_IMAGE" == *":latest"* ]]; then
              echo "‚ôªÔ∏è Restarting $dep to pull new image..."
              kubectl rollout restart deployment $dep || true
            else
              echo "‚úÖ $dep is already up-to-date."
            fi
          done

      # 1Ô∏è‚É£4Ô∏è‚É£ Verify Application Health (Dynamic Ingress IP)
      - name: Verify Deployment (Pods + App Health)
        run: |
          echo "üß© Checking pod statuses..."
          kubectl get pods -n default
          echo "üåê Verifying app endpoints..."
          INGRESS_IP=$(kubectl get ingress gamehub-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Detected Ingress IP: $INGRESS_IP"
          for path in "" "snake/" "2048/"; do
            APP_URL="http://$INGRESS_IP/$path"
            echo "Testing $APP_URL"
            if curl -I -s -o /dev/null -w "%{http_code}" $APP_URL | grep -q 200; then
              echo "‚úÖ $path reachable"
            else
              echo "‚ùå $path failed to respond"; exit 1
            fi
          done
          echo "üéØ All apps deployed and healthy!"
